import { CellType, } from "@holochain/client";
/**
 * Add all agents of all conductors to each other. Shortcuts peer discovery
 * through a bootstrap server or gossiping.
 *
 * @param conductors - Conductors to mutually exchange all agents with.
 *
 * @public
 */
export const addAllAgentsToAllConductors = async (conductors) => {
    await Promise.all(conductors.map(async (playerToShareAbout, playerToShareAboutIdx) => {
        const agentInfosToShareAbout = await playerToShareAbout
            .adminWs()
            .agentInfo({
            cell_id: null,
        });
        await Promise.all(conductors.map(async (playerToShareWith, playerToShareWithIdx) => {
            if (playerToShareAboutIdx !== playerToShareWithIdx) {
                playerToShareWith.adminWs().addAgentInfo({
                    agent_infos: agentInfosToShareAbout,
                });
            }
        }));
    }));
};
function assertZomeResponse(response) {
    return;
}
export const enableAndGetAgentApp = async (conductor, agentPubKey, installedAppInfo) => {
    const enableAppResponse = await conductor.adminWs().enableApp({
        installed_app_id: installedAppInfo.installed_app_id,
    });
    if (enableAppResponse.errors.length) {
        throw new Error(`failed to enable app: ${enableAppResponse.errors}`);
    }
    const cells = [];
    const namedCells = new Map();
    Object.keys(installedAppInfo.cell_info).forEach((role_name) => {
        installedAppInfo.cell_info[role_name].forEach((cellInfo) => {
            if (CellType.Provisioned in cellInfo) {
                const callableCell = getCallableCell(conductor, cellInfo[CellType.Provisioned], agentPubKey);
                cells.push(callableCell);
                namedCells.set(role_name, callableCell);
            }
            else if (CellType.Cloned in cellInfo &&
                cellInfo[CellType.Cloned].clone_id) {
                const callableCell = getCallableCell(conductor, cellInfo[CellType.Cloned], agentPubKey);
                cells.push(callableCell);
                namedCells.set(cellInfo[CellType.Cloned].clone_id, callableCell);
            }
            else {
                throw new Error("Stem cells are not implemented");
            }
        });
    });
    const agentApp = {
        appId: installedAppInfo.installed_app_id,
        agentPubKey,
        cells,
        namedCells,
    };
    return agentApp;
};
const getCallableCell = (conductor, cell, agentPubKey) => ({
    ...cell,
    callZome: async (request, timeout) => {
        const callZomeResponse = await conductor.appWs().callZome({
            ...request,
            cap_secret: null,
            cell_id: cell.cell_id,
            provenance: request.provenance ?? agentPubKey,
            payload: request.payload ?? null,
        }, timeout);
        assertZomeResponse(callZomeResponse);
        return callZomeResponse;
    },
});
/**
 * Get a shorthand function to call a cell's zome.
 *
 * @param cell - The cell to call the zome on.
 * @param zomeName - The name of the Zome to call.
 * @returns A function to call the specified Zome.
 *
 * @public
 */
export const getZomeCaller = (cell, zomeName) => (fnName, payload, timeout) => cell.callZome({
    zome_name: zomeName,
    fn_name: fnName,
    payload,
}, timeout);
